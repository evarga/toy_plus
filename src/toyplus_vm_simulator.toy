program TOY+ VM Simulator
/******************************************************************************
 *  Description: TOY+ virtual machine simulator. It executes the loaded 
 *               TOY/TOY+ program and exits when this simulated program halts.
 *  Input: TOY or TOY+ program.
 *  Output: Whatever output is generated by a simulated program.
 ******************************************************************************/

// M[00] - M[0F] values of registers of a simulated program.
00: 0000   constant 0x0000               
01: 0000   constant 0x0000               
02: 0000   constant 0x0000               
03: 0000   constant 0x0000               
04: 0000   constant 0x0000               
05: 0000   constant 0x0000               
06: 0000   constant 0x0000               
07: 0000   constant 0x0000               
08: 0000   constant 0x0000               
09: 0000   constant 0x0000               
0A: 0000   constant 0x0000               
0B: 0000   constant 0x0000               
0C: 0000   constant 0x0000               
0D: 0000   constant 0x0000               
0E: 0000   constant 0x0000               
0F: 0000   constant 0x0000               

// Main body implements the load()->run() sequence of actions.
10: 7101   R[1] <- 0001                  R[1] = fixed at 1
11: 72B5   R[2] <- 00B5                  R[2] = fixed at the base address
12: 73FF   R[3] <- 00FF                  R[3] = fixed at FF (stdin/stdout port)
13: FF17   R[F] <- PC; goto 17            
14: CE24   if (R[E] == 0) goto 24        
15: DE24   if (R[E] > 0) goto 24         
16: 0000   halt                          Halt if load() has failed.

function Load
// Description: Loads memory sectors comprising a TOY/TOY+ program starting at
//              the base address provided in R[2].
// Input: Size, relative starting address, and program's content all from stdin.
// Return address: R[F]
// Output: R[E] = relative starting address (PC), or -1 if the input program is 
//         too large to fit into memory.
// Temporary variables: R[4], R[5], R[6], and R[A]
17: 4402   R[4] <- R[2]                  i = base address;
18: 85FF   read R[5]                     scanf("%hX", &remaining);
19: 8EFF   read R[E]                     scanf("%hX", &pc);            
//                                       do {
1A: 8AFF   read R[A]                       scanf("%hX", &a);
1B: 2634   R[6] <- R[3] - R[4]           
1C: D61F   if (R[6] > 0) goto 1F           if (i == 255)
1D: 2E01   R[E] <- -R[1]                     return -1;
1E: EF00   goto R[F]                          
1F: BA04   M[R[4]] <- R[A]                 mem[i] = a;
20: 1441   R[4] <- R[4] + R[1]             i++;             
21: 2551   R[5] <- R[5] - R[1]             remaining--;
22: D51A   if (R[5] > 0) goto 1A         } while (remaining > 0);
23: EF00   goto R[F]                     return pc

function Run
// Description: Implements the fetch->increment->execute cycle.
// Input: R[E] = PC           
// Return address: None    
// Output: None        
// Temporary variables: R[4] - R[D] and R[F]
24: 9000   M[00] <- R[0]                 Ensure R[0] is always zero.

// Fetch instruction and increment PC
25: 4D0E   R[D] <- R[E]                  
26: FFAC   R[F] <- PC; goto AC           
27: AD0D   R[D] <- M[R[D]]               R[D] = instruction register's content
28: 1EE1   R[E] <- R[E] + R[1]           pc++

// Decode instruction
29: 740F   R[4] <- 000F                  
2A: 750C   R[5] <- 000C                  
2B: 66D5   R[6] <- R[D] >> R[5]          
2C: 3664   R[6] <- R[6] & R[4]           R[6] = opcode
2D: 7508   R[5] <- 0008                  
2E: 67D5   R[7] <- R[D] >> R[5]          
2F: 3774   R[7] <- R[7] & R[4]           R[7] = d or opcode extension
30: 7504   R[5] <- 0004                  
31: 68d5   R[8] <- R[D] >> R[5]          
32: 3884   R[8] <- R[8] & R[4]           R[8] = s or d in extended opcode
33: 39D4   R[9] <- R[D] & R[4]           R[9] = t
34: 3AD3   R[A] <- R[D] & R[3]           R[A] = addr

// R[B] and R[C] contains the content of registers R[s] and R[t], 
// respectively. It makes sense to set them here to save space.
35: AB08   R[B] <- M[R[8]]               
36: AC09   R[C] <- M[R[9]]               

// Halt or some extra TOY+ instruction
37: D657   if (R[6] > 0) goto 57         
38: D73A   if (R[7] > 0) goto 3A         
// 00xx -> halt
39: 0000   halt                          VM also exits with a simulated program
3A: 2771   R[7] <- R[7] - R[1]           
3B: D73F   if (R[7] > 0) goto 3F         
// 01st -> swap R[s], R[t]                       
3C: BB09   M[R[9]] <- R[B]               
3D: BC08   M[R[8]] <- R[C]               
3E: C024   goto 24                       
3F: 2771   R[7] <- R[7] - R[1]           
40: D745   if (R[7] > 0) goto 45         
// 02dt -> R[d] <- ~R[t]               
41: 2501   R[5] <- -R[1]                               
42: 255C   R[5] <- R[5] - R[C]           
43: B508   M[R[8]] <- R[5]               
44: C024   goto 24                       
45: 2771   R[7] <- R[7] - R[1]           
46: D74D   if (R[7] > 0) goto 4D         
// 03st -> push R[s] onto stack pointed by R[t]              
47: 2CC1   R[C] <- R[C] - R[1]           
48: BC09   M[R[9]] <- R[C]               
49: 4D0C   R[D] <- R[C]                  
4A: FFAC   R[F] <- PC; goto AC           
4B: BB0D   M[R[D]] <- R[B]               
4C: C024   goto 24                       
4D: 2771   R[7] <- R[7] - R[1]           
4E: C750   if (R[7] == 0) goto 50        
4F: 0000   halt                          Halt if extended opcode is invalid.
// 04dt -> pop into R[d] the top of stack pointed by R[t]       
50: 4D0C   R[D] <- R[C]                               
51: FFAC   R[F] <- PC; goto AC           
52: A40D   R[4] <- M[R[D]]               
53: B408   M[R[8]] <- R[4]               
54: 1CC1   R[C] <- R[C] + R[1]           
55: BC09   M[R[9]] <- R[C]               
56: C024   goto 24                       

57: 2661   R[6] <- R[6] - R[1]           
58: D65C   if (R[6] > 0) goto 5C         
// Add
59: 14BC   R[4] <- R[B] + R[C]           
5A: B407   M[R[7]] <- R[4]               This part is reused a lot (see below).
5B: C024   goto 24                       

5C: 2661   R[6] <- R[6] - R[1]           
5D: D660   if (R[6] > 0) goto 60         
// Subtract
5E: 24BC   R[4] <- R[B] - R[C]           
5F: C05A   goto 5A                       

60: 2661   R[6] <- R[6] - R[1]           
61: D664   if (R[6] > 0) goto 64         
// And
62: 34BC   R[4] <- R[B] & R[C]           
63: C05A   goto 5A                       

64: 2661   R[6] <- R[6] - R[1]           
65: D668   if (R[6] > 0) goto 68         
// Xor
66: 44BC   R[4] <- R[B] ^ R[C]           
67: C05A   goto 5A                       

68: 2661   R[6] <- R[6] - R[1]           
69: D66C   if (R[6] > 0) goto 6C         
// Shift left
6A: 54BC   R[4] <- R[B] << R[C]          
6B: C05A   goto 5A                       

6C: 2661   R[6] <- R[6] - R[1]           
6D: D670   if (R[6] > 0) goto 70         
// Shift right
6E: 64BC   R[4] <- R[B] >> R[C]          
6F: C05A   goto 5A                       

70: 2661   R[6] <- R[6] - R[1]           
71: D674   if (R[6] > 0) goto 74         
// Load address
72: BA07   M[R[7]] <- R[A]               
73: C024   goto 24                       

74: 2661   R[6] <- R[6] - R[1]           
75: D67E   if (R[6] > 0) goto 7E         
// Load
76: 243A   R[4] <- R[3] - R[A]           
77: D47A   if (R[4] > 0) goto 7A         
78: 84FF   read R[4]                     R[d] <- read(stdin)
79: C05A   goto 5A                       
7A: 4D0A   R[D] <- R[A]                  
7B: FFAC   R[F] <- PC; goto AC           
7C: A40D   R[4] <- M[R[D]]               
7D: C05A   goto 5A                       

// R[5] stores the content of R[d], which is needed several times below.
7E: A507   R[5] <- M[R[7]]               

7F: 2661   R[6] <- R[6] - R[1]           
80: D689   if (R[6] > 0) goto 89         
// Store        
81: 243A   R[4] <- R[3] - R[A]           
82: D485   if (R[4] > 0) goto 85         
83: 95FF   write R[5]                    print(R[d]) on stdout
84: C024   goto 24                       
85: 4D0a   R[D] <- R[A]                  
86: FFAC   R[F] <- PC; goto AC           
87: B50D   M[R[D]] <- R[5]               
88: C024   goto 24                       

89: 2661   R[6] <- R[6] - R[1]           
8A: D691   if (R[6] > 0) goto 91         
// Load indirect
8B: 243C   R[4] <- R[3] - R[C]           
8C: D48E   if (R[4] > 0) goto 8E         
8D: C078   goto 78                       References section from Load
8E: 4D0C   R[D] <- R[C]                  
8F: FFAC   R[F] <- PC; goto AC           
90: C07C   goto 7C                       References section from Load

91: 2661   R[6] <- R[6] - R[1]           
92: D699   if (R[6] > 0) goto 99         
// Store indirect             
93: 243C   R[4] <- R[3] - R[C]           
94: D496   if (R[4] > 0) goto 96         
95: C083   goto 83                       References section from Store
96: 4D0C   R[D] <- R[C]                  
97: FFAC   R[F] <- PC; goto AC           
98: C087   goto 87                       References section from Store

99: 2661   R[6] <- R[6] - R[1]           
9A: D69F   if (R[6] > 0) goto 9F         
// Branch if zero          
9B: C59D   if (R[5] == 0) goto 9D        
9C: C024   goto 24                       
9D: 4E0A   R[E] <- R[A]                  
9E: C024   goto 24                       

9F: 2661   R[6] <- R[6] - R[1]           
A0: D6A5   if (R[6] > 0) goto A5         
// Branch if positive             
A1: D5A3   if (R[5] > 0) goto A3         
A2: C024   goto 24                       
A3: 4E0A   R[E] <- R[A]                  
A4: C024   goto 24                       

A5: 2661   R[6] <- R[6] - R[1]           
A6: D6A9   if (R[6] > 0) goto A9         
// Jump indirect
A7: AE07   R[E] <- M[R[7]]                             
A8: C024   goto 24                       

// Jump and link
A9: BE07   M[R[7]] <- R[E]               
AA: 4E0A   R[E] <- R[A]                  
AB: C024   goto 24                       

function Get Absolute Address
// Input: R[D] = relative address            
// Return address: R[F]   
// Output: R[D] = absolute address            
// Temporary variables: R[A]
AC: 1DD2   R[D] <- R[D] + R[2]           
AD: 3DD3   R[D] <- R[D] & R[3]                         
AE: 2AD2   R[A] <- R[D] - R[2]           
AF: CAB2   if (R[A] == 0) goto B2        
B0: DAB2   if (R[A] > 0) goto B2         
B1: 0000   halt                          Halt if relative address is invalid.
B2: 2A3D   R[A] <- R[3] - R[D]           
B3: CAB1   if (R[A] == 0) goto B1        
B4: EF00   goto R[F]                     
